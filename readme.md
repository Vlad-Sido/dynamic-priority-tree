Задача: Очередь заказов с приоритетом, имитация работы планировщика задач.

Использованный алгоритм: модифицированная спаривающая куча.
Модификация состоит в добавлении метода увеличить ключ, что выполняется посредством удаления и передобавления вершины. Это же работает за амортизированное логарифмическое время, как и poll().

Класс `DynamicPriorityQueue<T>` - реализация алгоритма. Используется вспомогающий функциональный интерфейс `PriorityUpdater` (практически эквивалентет `Supplier<int>`, имеет функцию `priority()` возвращающую `int` и не принимающая аргумент).  
Добавление элемента требуется предоставление приоритета с помощью `PriorityUpdater` или впрямую целого числа.

Пример использования:
```java
DynamicPriorityQueue<Integer> queue = new DynamicPriorityQueue<>();    
queue.offer(1, 3); // Добавление элемента 1 с приоритетом 3
Integer[] prio = {4}; // Массив как представление динамеческого приоритета
queue.offer(2, () -> prio[0]); // Добавляет элемент 2 с приоритетом, который сейчас 4.
System.out.println(queue.peek()); // Печатает корень очереди, ожидается 1.
prio[0] = 0; // Изменяется приоритет элемента 2 на 0.
queue.update(2); // Оповещение очереди, что приоритет обновился.
System.out.println(queue.peek()); // Ожидается 2.
```