Задача: Очередь заказов с приоритетом, имитация работы планировщика задач.

Использованный алгоритм: модифицированная спаривающая куча.
Главная модификация состоит в добавлении метода увеличить ключ и изменение информации в вершинах для оптимизации этого метода. Количество указателей в вершине увеличено до 4, что замедляет структуру на константу, но позволяет выполнить увеличение ключа за константное время, когда изменяется не корень.

Класс `DynamicPriorityQueue<T, I>` - реализация алгоритма. Используется вспомогающий функциональный интерфейс `PriorityUpdater` (практически эквивалентет `Supplier<int>`, имеет функцию `priority()` возвращающую `int` и не принимающая аргумент). `T` - значение, хранящееся в очереди. `I` - уникальный идентификатор для каждого элемента.
Добавление элемента требуется предоставление приоритета с помощью `PriorityUpdater` или впрямую целого числа.

Главные операции:
* Пустой конструкор создает пустую очередь.
* `offer()` или `add()` добавляет новый элемент в очередь. Необходимо предоставить значение, идентификатор и либо функцию `PriorityUpdater`, либо целое число. При предоставлении целого числа как приоритет, элемент будет статический, без способа обновить приоритет. Возвращает `false` если уже есть элемент с таким идентификатором, иначе `true`.
* `peek()` или `element()` возвращает значение в корне очереди. Если очередь пуста, то возвращается `null`.
* `poll()` или `remove()` удаляет корень очереди и возвращает его значение. Если очередь пуста, то возвращается `null`.
* `remove()`, если предоставлен идентификатор, удаляет значение с ним.
* `update()` с предоставлением идентификатора обновляет приоритет определенной вершины. 
* `updateAll()` обновляет значения всех элементов в очереди.

Пример использования:
```java
DynamicPriorityQueue<Integer, String> queue = new DynamicPriorityQueue<>();
queue.offer(1, "foo", 3); // Добавление элемента 1 с приоритетом 3
Integer[] prio = {4}; // Массив как представление динамеческого приоритета
queue.offer(2, "bar", () -> prio[0]); // Добавляет элемент 2 с приоритетом, который сейчас 4.
System.out.println(queue.peek()); // Печатает корень очереди, ожидается 1.
prio[0] = 0; // Изменяется приоритет элемента 2 на 0.
queue.update("bar"); // Оповещение очереди, что приоритет обновился.
System.out.println(queue.peek()); // Ожидается 2.
```